<!DOCTYPE html>
<html>
<head>
<style>
body {
	background: #c0c0c0;
}

.board {
	background: #c0c0c0;
	line-height: 0;
	border-top: 2px solid #6e6e6e;
	border-right: 2px solid #fdfdfd;
	border-bottom: 2px solid #fdfdfd;
	border-left: 2px solid #6e6e6e;
	cursor: default;
	user-select: none;
	-webkit-user-select: none;
}

.tile {
	position: relative;
	width: 16px;
	height: 16px;
	border-top: 2px solid #fdfdfd;
	border-right: 2px solid #6e6e6e;
	border-bottom: 2px solid #6e6e6e;
	border-left: 2px solid #fdfdfd;
	background: #c0c0c0;
	display: inline-block;
	padding: 0;
	margin: 0;
}

.hover {
	background: #aaa;
}

.depressed {
	border-width: 1px 0 0 1px;
	border-style: solid;
	border-color: #6e6e6e;
	width: 19px;
	height: 19px;
}

.number {
	top: 50%;
	position: absolute;
	font-family: Arial Black, sans-serif;
	font-weight: bold;
	text-align: center;
	width: 100%;
}

.flagged {
	background: #aaa;
}

.misflagged {
	font-weight: normal;
	color: #f00;
}

.mined {
	background: #f00;
}

.one { color: blue; }
.two { color: green; }
.three { color: red; }
.four { color: #000080; }
.five { color: #800050; }
.six { color: #408080; }
.seven { color: black; }
.eight { color: gray; }

</style>
</head>
<body>
<div id="minesweeper"></div>
<button id="new_game">New Game</button>
<button id="validate">Validate</button>
<button id="cheat">Cheat</button>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
<script>
$(document).ready(function() {
	"use strict";
	
	var BOARD = (function(my) {
	
		// Text names of numbers, used for CSS classes.
		var numbers = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight'],
			width, height, mines, $boardElem, boardState,
			isMouseDown = false;
		
		my.Util = {
			// Ensure that the input is between min and max, setting it to either end of the bound (preferring min) if it does not fit.
			sanitizeBound: function(input, min, max) {
				if (!input) {
					return min;
				}
				
				if (input < min) {
					return min;
				}
				
				if (input > max) {
					return max;
				}
				
				return input;
			},
			
			indexForCoordinates: function(x, y) {
				return x + y * width;
			},
			
			coordinatesForIndex: function(index) {
				return {
					column: index % width,
					row: Math.floor(index / width)
				};
			}
		};
		
		my.Tile = {
			// Returns the neighbor tiles for a tile at the given index.
			getNeighbors: function(index) {
				var x, y, adjacentTileIdx,
					coordinates = BOARD.Util.coordinatesForIndex(index),
					neighbors = [];
				
				for (x = -1; x <= 1; x++) {
					for (y = -1; y <= 1; y++) {
						if ((coordinates.column + x >= 0 && coordinates.column + x < width && coordinates.row + y >= 0 && coordinates.row + y < height) // If the coordinates are in the bounds of the board...
							&& (x !== 0 || y !== 0)) { // x and y are not both 0 at the same time so that the tile itself is not included in the neighbors...
							adjacentTileIdx = BOARD.Util.indexForCoordinates(coordinates.column + x, coordinates.row + y);
							neighbors[neighbors.length] = boardState[adjacentTileIdx];
						}
					}
				}
				
				return neighbors;
			},

			get: function(board, index, $tile) {
				var that = this,
					coordinates = BOARD.Util.coordinatesForIndex(index);
			
				$tile.data('column', coordinates.column);
				$tile.data('row', coordinates.row);
				
				return {
					mine: false,
					flagged: false,
					number: 0,
					$tile: $tile,
					column: coordinates.column,
					row: coordinates.row,
					
					// Returns an array of Tiles that are adjacent to this tile, including diagonals.
					getNeighbors: function() {
						return (function() {
							return that.getNeighbors(index);
						}());
					},
					
					isFlagged: function() {
						return this.flagged;
					},
					
					setFlagged: function(flagged) {
						if (flagged) {
							this.$tile.addClass('flagged');
							this.flagged = true;
						} else {
							this.$tile.removeClass('flagged');
							this.flagged = false;
						}
					},
					
					reveal: function() {
						if (this.mine) {
							this.$tile.addClass('mined');
							board.revealMines();
							board.disable();
						} else if (this.number > 0) {
							this.$tile.html('<div class="number ' + numbers[this.number] + '">' + this.number + '</div>');
						} else {
							var tiles = [this], t,
								addNeighborsCallback = function(neighborTile) {
									if (!neighborTile.$tile.data('considering') && !neighborTile.$tile.hasClass('depressed')) {
										// Mark neighbor tile as under consideration so that we do not add it to the stack again.
										neighborTile.$tile.data('considering', true);
										tiles[tiles.length] = neighborTile;
										//console.log('Added neighbor: ', neighborTile, neighborTile.column, neighborTile.row);
									}
								};
							
							while (tiles.length > 0) {
								t = tiles.pop();
								t.$tile.removeData('considering');
								
								//console.log('Looking at tile:', t, t.column, t.row);
								if (!t.mine && !t.flagged) {
									if (t.number > 0) {
										//console.log('(' + t.column + ', ' + t.row + ') is a number. Revealing.');
										t.$tile.addClass('depressed');
										t.$tile.html('<div class="number ' + numbers[t.number] + '">' + t.number + '</div>');
									} else {
										//console.log('(' + t.column + ', ' + t.row + ') is an empty square. Revealing and adding neighbors.');
										t.$tile.addClass('depressed');
										$.map(t.getNeighbors(), addNeighborsCallback);
									}
								}
							}
						}
					}
				};
			}
		};
		
		my.init = function(myWidth, myHeight, myMines) {
			// Width of board, in tiles.
			width = BOARD.Util.sanitizeBound(myWidth, 8, 32);
			// Height of board, in tiles.
			height = BOARD.Util.sanitizeBound(myHeight, 8, 32);
			// Number of mines on the board. Arbitrarily, no more than half the tiles can be mines.
			mines = BOARD.Util.sanitizeBound(myMines, 10, width * height / 2);
			
			// Element that contains HTML for board.
			$boardElem = null;
			// Array of objects describing state of board. See: initializeBoardState()
			boardState = [];
		};
		
		// Creates the markup for the board in the given element and attaches event handlers.
		function createBoard(elem) {
			var board = '<div class="board">',
				tile = '<div class="tile"></div>',
				i, j;
			
			for (i = 0; i < width; i++) {
				for (j = 0; j < height; j++) {
					board += tile;
				}
				board += '<br />';
			}
			board += '</div>';
			
			$(elem).html(board);
			$boardElem = $('div.board', $(elem));
			
			// Calculate board size based on tile dimensions and borders.
			// Hardcode 20 = 16 tile width and height + 2 each for border.
			// We could also use a plugin to read the CSS style.
			$boardElem.css('width', 20 * width);
			$boardElem.css('height', 20 * height);
		}
		
		function attachEventHandlers() {
			$boardElem.on({
				mousedown: function(event) {
					// Prevent drag behavior.
					event.preventDefault();

					var tile = $(this).data('tile');
					
					isMouseDown = true;
					
					// If it's the right mouse button that's down...
					if (event.which === 3) {
						// Cancel further mouse behaviors.
						isMouseDown = false;
						
						
						if (!$(this).hasClass('depressed')) {
							tile.setFlagged(!tile.isFlagged());
						}
						
						return;
					}
					
					// If the tile is already pressed, nothing we can do now.
					$(this).trigger('mouseenter');
				},
				
				mouseenter: function() {
					$(this).data('wasDepressed', $(this).hasClass('depressed'));
					if (isMouseDown && !$(this).data('tile').flagged) {	
						if (!$(this).data('wasDepressed')) {
							$(this).addClass('depressed');
						}
					}
				},
				
				mouseleave: function() {
					if (isMouseDown && !$(this).data('tile').flagged) {
						if (!$(this).data('wasDepressed')) {
							$(this).removeClass('depressed');
						}
					}
				},
				
				mouseup: function() {
					var tile = $(this).data('tile');
					
					if (isMouseDown && !tile.flagged) {
						isMouseDown = false;
						tile.reveal();
						$(this).data('wasDepressed', true);
					} else if ($(this).data('tile').flagged) {
						isMouseDown = false;
					}
				},
				
				contextmenu: function() {
					return false;
				}
			}, 'div.tile');
		}
		
		function placeMines() {
			var tile, tileIdx,
				minesLeft = mines,
				incrementNeighborCallback = function(neighborTile) {
					//console.log('Mine: (' + tile.column + ', ' + tile.row + ') -- Adjacent Tile: (' + (neighborTile.column) + ', ' + (neighborTile.row) + ')');
					if (neighborTile.mine) {
						return;
					}
					
					neighborTile.number = (neighborTile.number || 0) + 1;
				};
			
			while (minesLeft > 0) {
				// Chooose a random location to place a mine.
				tileIdx = Math.floor(Math.random() * ((width * height) - 1));
				tile = boardState[tileIdx];
				if (!tile.mine) {
					minesLeft -= 1;
					
					tile.mine = true;
									
					// Increment numbers in tiles around mine.
					$.map(tile.getNeighbors(), incrementNeighborCallback);
				}
			}
		}
		
		// Reveals all mine squares and incorrectly flagged tiles.
		function revealMines(cheat) {
			var i, n;
			
			for (i = 0, n = boardState.length; i < n; i++) {
				if (boardState[i].flagged && !boardState[i].mine) {
					boardState[i].$tile.html('<div class="number">&#x263c;</div><div class="number misflagged">X</div>');
					boardState[i].$tile.removeClass('flagged');
					boardState[i].$tile.addClass('depressed');
				} else if (!boardState[i].flagged && boardState[i].mine) {
					boardState[i].$tile.html('<div class="number">&#x263c;</div>');
					if (!cheat) {
						boardState[i].$tile.addClass('depressed');
					}
				}
			}
		}
		
		function disable() {
			$boardElem.off('mousedown');
			$boardElem.off('mouseup');
		}
		
		function initializeBoardState() {
			var tiles = $boardElem.children('div.tile').toArray(),
				i, n;
			
			for (i = 0, n = tiles.length; i < n; i++) {
				boardState[i] = BOARD.Tile.get({ revealMines: revealMines, disable: disable }, i, $(tiles[i]));
				$(tiles[i]).data('tile', boardState[i]);
			}
		}
		
		function initializeBoard() {
			initializeBoardState();
			placeMines();
		}
		
		// Draws the board and initializes game state.
		my.render = function(elem) {
			createBoard(elem);
			attachEventHandlers();
			initializeBoard();
		};
		
		my.validate = function() {
		};
		
		// Reveals all squares.
		my.reveal = function() {
			var i, n;
			
			for (i = 0, n = boardState.length; i < n; i++) {
				/*
				boardState[i].$tile.addClass('depressed');
				if (boardState[i].mine) {
					boardState[i].$tile.html('<div class="number">&#x263c;</div>');
				} else if (boardState[i].number > 0) {
					boardState[i].$tile.html('<div class="number ' + numbers[boardState[i].number] + '">' + boardState[i].number + '</div>');
				}
				*/
				
				if (boardState[i].mine) {
					boardState[i].$tile.html('<div class="number">&#x263c;</div>');
				} else if (boardState[i].number > 0) {
					boardState[i].$tile.addClass('depressed');
					boardState[i].$tile.html('<div class="number ' + numbers[boardState[i].number] + '">' + boardState[i].number + '</div>');
				} else if (!boardState[i].mine) {
					boardState[i].$tile.addClass('depressed');
				}
			}
		};
		
		// For debug use only:
		my.rm = revealMines;
		
		return my;
	}(BOARD || {}));

	BOARD.init();
	BOARD.render($('#minesweeper'));
	BOARD.validate(function() {
	});
	//BOARD.rm();
	
	$('#new_game').on('click', function() { BOARD.init(); BOARD.render($('#minesweeper')); });
	$('#cheat').on('click', function() { BOARD.rm(true); });
});
</script>
</body>
</html>